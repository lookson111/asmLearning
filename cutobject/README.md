# mesh_cutting
Задачка нумеро два - про разрезалку пополам.

Дано : полигональная сетка.
Сетка задается набором вершин и индексами вершин граней.
Вершины могут содержать достаточно произвольный набор параметров - 
координаты, цвет, нормаль, текстурные координаты - в общем что угодно.
Индексы граней - это просто массив int. Грани лежат в нем подряд в форме 
(<число вершин>, сами вершины).
То есть треугольник будет иметь вид (3, V1, V2, V3), а квад - (4, V1, V2, V3, V4).
Грани в общем случае могут иметь произвольное число вершин.
- тривиальный уровень : грань - это треугольник.
- базовый уровень : грань является выпуклым полигоном. 
- усложненный уровень : грань является произвольным полигоном.
- бонусный уровень : грань является произвольным полигоном с дырками.
дырки задаются как контура с отрицательным числом узлов, т.е.
грань содержит внешний контур (он всегда самый превый и один), 
за которым может следовать
несколько контуров-дырок с отрицательным числом вершин.

Требуется : реализовать разрезание такой сетки плоскостью на две.
Разрезалка должна быть оптимизирована по скорости и выдавать 
корректные результаты - 
в том смысле, что получившиеся куски должны иметь аккуратную 
общую границу и не торчать на другую стороны плоскости.
Плоскость в общем случае может быть любая, но в целях оптимизации 
можно считать, что она перпендикулярна одной 
из координатных осей. Кроме того следует учесть ситуацию, когда 
полученные части сеток немедленно могут быт подвергнуты
дальнейшему разрезанию.

Более-менее формальное описание - во вложении, а если своими
словами - то речь идет о разрезании полигональных сеток на части
(например - для хранения в октодереве). То есть у нас есть
индексированная сетка (массив вершин + индексы вершин граней), и нам
надо эту сетку разрезать плоскостью на две.
Сетки могут быть тяжелые (очень тяжелые, сотни тысяч и миллионы граней -
это реальная ситуация), то есть требуется оптимизация (как по скорости,
так и по памяти) - например минимизация копирований\перекладок вершин.
Второй момент - это гарантия корректности разрезания, т.е. отрезанные
части не должны выступать за пределы плоскости разрезания, ну и
корректно сопрягаться в этой плоскости.
Третий момент - поскольку речь идет об октри, то весьма вероятна
ситуация, когда сетка может быть последовательно разрезана несколькими
разными плоскостями (например - по разным осям), что вполне может давать
дополнительные возможности оптимизации.

Что должно получиться в результате : проектик на Visual Studio, который
такую разрезалку будет реализовывать и как-то иллюстрировать, тут
каких-то особых требований нет, разве что желательно избегать тяжелых
сторонних фрэймворков вроде boost :)
Если возникнет желание\необходимость что-то использовать - то лучше
заранее согласовать, чтобы никому не было обидно.

# Install 
## Ubuntu
```
sudo apt update
sudo apt upgrade
sudo apt install python3 python3-pip cmake
sudo pip install conan==1.*
sudo apt install libudev-dev libudev-dev libudev-dev libgl-dev libgl1-mesa-dev libx11-xcb-dev libfontenc-dev libice-dev libsm-dev libxaw7-dev libxcomposite-dev libxcursor-dev libxdamage-dev libxext-dev libxfixes-dev libxi-dev libxinerama-dev libxkbfile-dev libxmu-dev libxmuu-dev libxpm-dev libxrandr-dev libxrender-dev libxres-dev libxss-dev libxt-dev libxtst-dev libxv-dev libxvmc-dev libxxf86vm-dev libxcb-render0-dev libxcb-render-util0-dev libxcb-xkb-dev libxcb-icccm4-dev libxcb-image0-dev libxcb-keysyms1-dev libxcb-randr0-dev libxcb-shape0-dev libxcb-sync-dev libxcb-xfixes0-dev libxcb-xinerama0-dev libxcb-dri3-dev uuid-dev libxcb-cursor-dev libxcb-util0-dev libxcb-util-dev libglu1-mesa-dev
conan install .. --build=missing -s build_type=Debug -s compiler.libcxx=libstdc++11
cmake .. -DCMAKE_BUILD_TYPE=Debug
cmake --build .
```
## Windows
Install python with pip. Install MSVC, cmake.
```
conan install .. --build=missing -s build_type=Debug
cmake .. -DCMAKE_BUILD_TYPE=Debug
cmake --build .
```
